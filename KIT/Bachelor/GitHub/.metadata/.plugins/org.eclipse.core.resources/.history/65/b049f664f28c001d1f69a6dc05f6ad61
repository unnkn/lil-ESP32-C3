/*
 * mcu_tracer_appspec.c
 *
 *  Created on: 18.03.2020
 *      Author: Michael
 *
 *      Implements application specific routines, required for the MCU_TRACER Master Device
 */

#include "dps/unified.h"
#include "adc.h"

//standard functions
const char mcu_tracer_time_in_variables_label[] = "SysTicks";

//example specific
const char mcu_tracer_example_bool_label[] = "Example boolean";
const char mcu_tracer_vadc1_label[] = "ADC CH1 voltage (V)";
const char mcu_tracer_adcraw_label[] = "raw ADC";
const char mcu_tracer_adcrawV_label[] = "ADC RAW Values in V";
const char mcu_tracer_dutyCycle_label[] = "Duty Cycle (%)";
const char mcu_tracer_example_float2_label[] = "Example float (read-only)";

const char debug_dummfunction_msg[] = "Dummy Function successfully executed";
void mcu_tracer_dummyfunc(void) {
	mcu_tracer_msg(&debug_dummfunction_msg[0]);
}

void mcu_tracer_fill_variables(void) {
	uint16_t fill = 0;

	mcutracer_variables[fill].type = MCU_TRACER_DATA_TYPE_INT;
	mcutracer_variables[fill].rw = MCU_TRACER_READ;
	mcutracer_variables[fill].data_l = (int32_t*) &mcu_tracer_time;
	mcutracer_variables[fill].loadonpowerup = MCU_TRACER_LOADONPOWERUP_OFF;
	strlcpy(mcutracer_variables[fill].label,
			&mcu_tracer_time_in_variables_label[0],
			MCU_TRACER_SETVARIABLES_LABEL_LENGTH);
	mcutracer_variables[fill].callback = NULL;
	fill++;

	mcutracer_variables[fill].type = MCU_TRACER_DATA_TYPE_FLOAT;
	mcutracer_variables[fill].rw = MCU_TRACER_READ;
	mcutracer_variables[fill].data_f = &adc1_values[0];
	mcutracer_variables[fill].loadonpowerup = MCU_TRACER_LOADONPOWERUP_OFF;
	strlcpy(mcutracer_variables[fill].label, &mcu_tracer_adcraw_label[0],
	MCU_TRACER_SETVARIABLES_LABEL_LENGTH);
	mcutracer_variables[fill].callback = NULL;
	fill++;

	mcutracer_variables[fill].type = MCU_TRACER_DATA_TYPE_FLOAT;
	mcutracer_variables[fill].rw = MCU_TRACER_READ;
	mcutracer_variables[fill].data_f = &adc1_raw_voltage;
	mcutracer_variables[fill].loadonpowerup = MCU_TRACER_LOADONPOWERUP_OFF;
	strlcpy(mcutracer_variables[fill].label, &mcu_tracer_adcrawV_label[0],
			MCU_TRACER_SETVARIABLES_LABEL_LENGTH);
	mcutracer_variables[fill].callback = NULL;
	fill++;

//	mcutracer_variables[fill].type = MCU_TRACER_DATA_TYPE_BOOL;
//	mcutracer_variables[fill].rw = MCU_TRACER_READWRITE;
//	mcutracer_variables[fill].data_l = (int32_t *)&example_bool;
//	mcutracer_variables[fill].data_setmin_i = 0;
//	mcutracer_variables[fill].data_setmax_i = 1;
//	mcutracer_variables[fill].loadonpowerup = MCU_TRACER_LOADONPOWERUP_ON;
//	strlcpy(mcutracer_variables[fill].label, &mcu_tracer_example_bool_label[0], MCU_TRACER_SETVARIABLES_LABEL_LENGTH);
//	mcutracer_variables[fill].callback = NULL;
//	fill++;
//
	mcutracer_variables[fill].type = MCU_TRACER_DATA_TYPE_INT;
	mcutracer_variables[fill].rw = MCU_TRACER_READWRITE;
	mcutracer_variables[fill].data_l = &prozent;
	*(mcutracer_variables[fill].data_l) = 0; //default value
	mcutracer_variables[fill].data_setmin_i = 0;
	mcutracer_variables[fill].data_setmax_i = 100;
	mcutracer_variables[fill].loadonpowerup = MCU_TRACER_LOADONPOWERUP_ON;
	strlcpy(mcutracer_variables[fill].label, &mcu_tracer_dutyCycle_label[0], MCU_TRACER_SETVARIABLES_LABEL_LENGTH);
	mcutracer_variables[fill].callback = NULL;
	fill++;
//
//	mcutracer_variables[fill].type = MCU_TRACER_DATA_TYPE_FLOAT;
//	mcutracer_variables[fill].rw = MCU_TRACER_READWRITE;
//	mcutracer_variables[fill].data_f = &example_float;
//	*(mcutracer_variables[fill].data_f) = 3.45; //default value
//	mcutracer_variables[fill].data_setmin_f = 0.0f;
//	mcutracer_variables[fill].data_setmax_f = 100.0f;
//	mcutracer_variables[fill].loadonpowerup=MCU_TRACER_LOADONPOWERUP_ON;
//	strlcpy(mcutracer_variables[fill].label, &mcu_tracer_example_float_label[0], MCU_TRACER_SETVARIABLES_LABEL_LENGTH);
//	mcutracer_variables[fill].callback = NULL;
//	fill++;
//
//	mcutracer_variables[fill].type = MCU_TRACER_DATA_TYPE_FLOAT;
//	mcutracer_variables[fill].rw = MCU_TRACER_READ;
//	mcutracer_variables[fill].data_f = &example_float2;
//	*(mcutracer_variables[fill].data_f) = 67.8; //default value
//	mcutracer_variables[fill].data_setmin_f = 0.0f;
//	mcutracer_variables[fill].data_setmax_f = 100.0f;
//	mcutracer_variables[fill].loadonpowerup = MCU_TRACER_LOADONPOWERUP_ON;
//	strlcpy(mcutracer_variables[fill].label, &mcu_tracer_example_float2_label[0], MCU_TRACER_SETVARIABLES_LABEL_LENGTH);
//	mcutracer_variables[fill].callback = NULL;
//	fill++;
}

const char store_variables_label[] = "Toggle Green";
const char load_variables_label[] = "Load variables from EEPROM";
const char example_function_label[] = "Reset all variables";

void mcu_tracer_fill_func(void) {
	int fipo = 0;

	strlcpy(mcutracer_functions[fipo].label, &store_variables_label[0],
	MCU_TRACER_FUNCTIONS_LABEL_LENGTH);
	mcutracer_functions[fipo].func_ptr = led_green_toggle;
	fipo++;
//
//	strlcpy(mcutracer_functions[fipo].label,&load_variables_label[0],MCU_TRACER_FUNCTIONS_LABEL_LENGTH);
//	mcutracer_functions[fipo].func_ptr=mcu_tracer_eeprom_varload;
//	fipo++;

//	strlcpy(mcutracer_functions[fipo].label, &example_function_label[0], MCU_TRACER_FUNCTIONS_LABEL_LENGTH);
//	mcutracer_functions[fipo].func_ptr = example_function;
//	fipo++;
}

//Callback called, when the initialisation is complete
void mcu_tracer_appspec_initcomplete_callback(void) {
	//mcu_tracer_find_variable_by_name((char*) &mcu_tracer_appsec_output_voltage[0], &id)
	//mcu_tracer_bind_variable_float32(id, &update_display_voltage);
	//mcu_tracer_bind_callback(id, display_voltage_avg);
	//mcu_tracer_initcompleted=MCU_TRACER_REQ_STATE_MASCHINE_INIT_FUNC;
	//mcu_tracer_req_task_fast_update_trigger();
	//must be set to one after init is completed successfully
	//counter_reinit=0;
}

void mcu_tracer_appspec_function_init_callback(void) {
	//mcu_tracer_initcompleted=MCU_TRACER_REQ_STATE_MASCHINE_CONTINOUS_VAR_REQ;
	//mcu_tracer_req_task_fast_update_trigger();
	//counter_reinit=0;
}

//callback is called, when all values are updated.
void mcu_tracer_appspec_allupdate_callback(void) {
	//counter_no_update=0;
	//counter_reinit=0;
//	mcu_tracer_req_task_fast_update_trigger();
}

void mcu_tracer_appspec_custom_updates(uint8_t *data, uint16_t *pos,
		uint16_t maxlen) {
	//not required for slave
}

void mcu_tracer_pingcallback(void) {
	//
}

void mcu_tracer_emergency_callback(void) {
	//shutdown();
}

uint32_t mcu_tracer_uniqueid0(void) {
	return LL_GetUID_Word0();
}
uint32_t mcu_tracer_uniqueid1(void) {
	return LL_GetUID_Word1();
}
uint32_t mcu_tracer_uniqueid2(void) {
	return LL_GetUID_Word2();
}

void mcutracer_userfunc(void) {
	//
}

void mcutracer_rec_task_worker(void) {
	mcu_tracer_fill_variables();
	mcu_tracer_fill_func();
	mcu_tracer_usart_init();
#if I2C_MEM_ENABLE > 0
	mcu_tracer_eeprom_init();
	#endif

	while (1) {
		vTaskDelay(10);
		//mcu_tracer_logbuf_submit();
		mcu_tracer_time_tick();
		//Look if we have any data, to add to recieve buffer
		mcu_tracer_usart_pollfordata();
		//execute portionierer
		mcu_tracer_rec_portionierer_process();
		//flush sendbuffer, answers to master
		mcutracer_sendbuffer_flush();
	}
}

//typedef struct i2cmem_first{
//	char manufacturer[I2CMEM_MANUFACTURER_LENGTH]; 		//"Digital Power Systems (DPS), Karlsruhe, Germany"
//	char description[I2CMEM_DESCRIPTION_LENGTH];  		//"DPS-HP-480"
//	uint32_t uniqueid[3];  		//Unique Chip ID
//	char date[I2CMEM_DATE_LENGTH];         		//https://gcc.gnu.org/onlinedocs/cpp/Standard-Predefined-Macros.html
//	char time[I2CMEM_TIME_LENGTH];  				//https://gcc.gnu.org/onlinedocs/cpp/Standard-Predefined-Macros.html
//	uint8_t version_major;
//	uint8_t version_minor;
//	uint64_t timesaved;
//} i2cmem_first_page_t;

#if I2C_MEM_ENABLE > 0
const char firstpage_manufacturer[I2CMEM_MANUFACTURER_LENGTH]="Digital Power Systems (DPS), Karlsruhe, Germany";
const char firstpage_description[I2CMEM_MANUFACTURER_LENGTH]="MCU Tracer example";
const char firstpage_builddate[I2CMEM_DATE_LENGTH]=__DATE__;
const char firstpage_buildtime[I2CMEM_TIME_LENGTH]=__TIME__;
const int32_t firstpage_version_major=0;
const int32_t firstpage_version_minor=1;

void mcutracer_firstpage_information_fill(i2cmem_first_page_t* fp){
	strlcpy(fp->manufacturer,&firstpage_manufacturer[0],I2CMEM_MANUFACTURER_LENGTH);
	strlcpy(fp->description,&firstpage_description[0],I2CMEM_MANUFACTURER_LENGTH);
	memcpy(fp->uniqueid, (void*) UID_BASE_ADDRESS,12);
	strlcpy(fp->date,&firstpage_builddate[0],I2CMEM_DATE_LENGTH);
	strlcpy(fp->time,&firstpage_buildtime[0],I2CMEM_TIME_LENGTH);
	fp->version_major=firstpage_version_major&0xff;
	fp->version_minor=firstpage_version_minor&0xff;
	fp->pages=I2C_EEPROM_PAGES;
}
#endif

